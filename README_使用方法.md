# Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Beta

---
下面是一份面向中国用户、详细而友好的使用说明书。将帮助您从安装/打开此应用起，一步步了解如何借助这四个 Python 文件（`main.py`、`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py` 以及另外两个功能模块）来完成世界语文本的“汉字化”或“带汉字注释”转换。由于功能较强大，说明较长，建议仔细阅读。


---

# 世界语文本（含汉字）替换工具——中文使用说明

## 1. 概览

本工具（由 4 个 `.py` 文件构成）通过 **Streamlit** 在浏览器中运行，可让您：
1. **将世界语文本自动转换/替换为** 含汉字或中文注释的文本（也支持带有 HTML + Ruby 注释的形式）。
2. **根据自己的需要生成替换规则**（JSON 文件），再在主界面导入这一规则，对海量世界语文本进行自动替换。

### 四个主要文件
1. **`main.py`**：主应用程序文件。用户一般从这里启动程序，主要执行“文字替换、生成结果文本”。
2. **`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`**：放在 `pages/` 文件夹下，用于生成大规模替换规则 JSON 的辅助页。
3. **`esp_text_replacement_module.py`**：底层功能模块之一，提供“世界语字符转换、%...%跳过替换、@...@局部替换”等核心逻辑。
4. **`esp_replacement_json_make_module.py`**：另一个底层功能模块，支持 CSV/JSON 合并处理、并行化生成大规模 JSON 文件、以及 HTML ruby 样式处理等。

运行方式：您只需在本工具所在目录下，执行 `streamlit run main.py`，浏览器中就会出现可视化界面。

---

## 2. 安装及运行

1. **确保环境中已安装 Python 3.x**。
2. **安装 Streamlit**：`pip install streamlit`
3. （可选）如果要用到底层模块中 BFS 等并行，需要 `multiprocessing`，Python 标准库已有，无需额外安装。
4. **在命令行进入本项目文件夹**，执行：
   ```bash
   streamlit run main.py
   ```
   或者在 IDE（如 VSCode）中执行 `streamlit run main.py`。
5. 打开浏览器中自动出现的链接（或复制终端中的链接），即可进入应用主页。

---

## 3. 主页面（`main.py`）——将世界语文本转换/替换为汉字

### 3.1 加载替换规则 JSON 文件

- **两种方式**：
  - ① *使用默认 JSON*：点选“使用默认 JSON”，系统会自动读取内置的 `./Appの运行に使用する各类文件/最终的な替换用リスト(列表)(合并3个JSON文件).json`。  
  - ② *上传自定义 JSON*：如果您曾在“生成 JSON 工具”页合并过多条规则生成了新的 JSON，就可在这里上传使用。

- 如果一切正常，会提示“成功读取 JSON 文件”，并把该 JSON 内包含的各种替换列表读入内存备用。

### 3.2 （可选）配置并行处理

- 在页面“高级设置：并行处理选项”中，可以勾选“使用并行处理”，并设置进程数（2~4 一般即可）。
- 并行处理可以**显著加速**大文本替换，但在非常小文本时区别不大。

### 3.3 选择输出格式（HTML/带括号/仅替换等）

- 在 `format_type` 下拉菜单中可以选：
  - `HTML格式_Ruby文字_大小调整`：会把世界语文本 + 中文注释以 `<ruby>…<rt>…</rt></ruby>` 形式包装并根据宽度自动调整 Ruby 字体大小。
  - `HTML格式_Ruby文字_大小调整_汉字替换`：相反地，把汉字当做“主要文字”，世界语当做 Ruby。
  - `HTML格式`、`HTML格式_汉字替换`：更简单的 HTML Ruby。无自动字体大小调整。
  - `括弧(号)格式`、`括弧(号)格式_汉字替换`：示例 `Esperant(世界语)` 或 `世界语(Esperant)`。
  - `替换后文字列のみ(仅)保留(简单替换)`：纯粹保留替换结果，不加任何 Ruby 或括号。

### 3.4 输入世界语文本（手动或文件）

- 勾选“手动输入”，可直接在文本框粘贴世界语段落。
- 或选择“上传文件”（txt、csv、md 均可）。
- 系统会将你输入的文本保存在 `text0_value` 中，供后续替换。

### 3.5 特殊标记

- 如果您用 `%...%` 包裹一段文本，则此段会**跳过任何替换**。
- 如果您用 `@...@` 包裹一段文本，则此段只进行“局部替换”（即只使用局部替换列表，比如 CSV 中收集的简单对应关系），不会经过主替换规则。

### 3.6 提交后自动执行替换

- 选择好配置后，点击“提交”。
- 程序会执行下列操作：
  1. 如果勾选并行，则调用 `parallel_process()` 并自动分割文本为多行并发处理；
  2. 否则单线程执行 `orchestrate_comprehensive_esperanto_text_replacement()`。
  3. 应用您选定的世界语字母形式转换（如“上标形式”把 `cx->ĉ` 等）。
  4. 如果选用 HTML 格式，会最后加上 `<style>` 以方便浏览器端 Ruby 效果。

### 3.7 查看并下载结果

- 替换完毕后，页面会显示一个预览。如果行数非常多，系统只显示前 247 行 + 后 3 行，避免卡顿。
- 如果输出是 HTML 相关格式，会提供一个“HTML 预览” Tab，可在页面直接渲染效果。
- 也会有一个“HTML 源码”Tab 显示源码。
- 最下方有“下载转换结果 (HTML)”按钮，可将处理后完整文本另存为 `.html` 文件。

到此，即完成了**世界语文本 -> 带汉字或中文注释的文本**的核心操作。

---

## 4. “生成 JSON 工具”页面（`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`）

若您想自定义更加复杂或海量的词根替换规则（比如 5~10 万条词根及活用后缀自动展开），则需要一个庞大的 JSON 文件。该页面可以帮助您**合并 CSV + 自定义 JSON**，自动创建“合并三份内容的替换 JSON”。

### 4.1 典型使用场景

- 您手头有一个 CSV（包含数千或上万行世界语词根与对应翻译/汉字），然后想把它变成主程序可读的 `.json`。
- 还可能需要补充一些个别词根的特殊拆分法（如某词根先要去掉多少前缀，或自动添加某些动词后缀），则要在 `世界语单词词根分解方法の使用者自定义设置.json` 里写好规则。
- 或者您想对某些词手动指定替换后的独特汉字写法，可编辑“自定义替换后文字” JSON。
- 最终一步：本页面把这些信息全部读取、处理后，生成一份最终 `.json` 文件。  
  这份文件带有：
  1. 全域替换列表  (世界语词根 -> placeholder -> 汉字或中文翻译)
  2. 二字词根替换列表 (专门处理 `$ar`, `$in` 等短后缀或前缀)
  3. 局部替换列表  (处理 `@...@` 时使用)

### 4.2 大致流程

1. **选择 CSV 文件**：可上传新的，也可用默认 `世界语词根-中文注释对应列表.csv`。其中第一列是词根，第二列是翻译/汉字。
2. **选择词根分解法 JSON**：也可上传或用默认 `世界语单词词根分解方法の使用者自定义设置.json`。该文件内可编写类似 `["am", "dflt", ["verbo_s1"]]` 表示 `am` 这个词根默认加上动词后缀 `(as, is, os 等)`。
3. **选择替换后文字 JSON**（不太常用）：默认或自定义。
4. **勾选并行处理**（可选）：如果 CSV 或内置词典很大（如数万行），可以加速。
5. **点击“生成并下载替换用 JSON 文件”**：系统会：
   - 读取世界语大词典 `PEJVO(...)E_stem_with_Part_Of_Speech_list.json`（大约几万条）；
   - 读取`世界语全部词根_约11137个` 文件；
   - 逐条用 CSV 信息 + 自定义 JSON 信息去“safe_replace”，再补充动词/后缀优先级等逻辑；
   - 形成 “全域替换列表”“二字词根替换列表”“局部替换列表” 三合一；
   - 将其写入一个 JSON 并提供下载。

### 4.3 生成后的 JSON 怎么用？

- 在主页面 `main.py` 中的“选择替换规则 JSON 文件”的环节里直接上传您生成的这份 JSON，就可以了。

---

## 5. 底层功能模块说明

### 5.1 `esp_text_replacement_module.py`

- **世界语字符转换**：如 `x_to_circumflex`、`hat_to_circumflex` 等，把 `cx`/`c^` 变成 `ĉ`。
- **`safe_replace()`** 函数：分两步 `(old->placeholder->new)` 避免交叉替换冲突。
- **`orchestrate_comprehensive_esperanto_text_replacement()`**：核心函数，将 `%...%` 跳过、`@...@` 局部替换、大范围替换、二字根替换 多步合并执行。
- **`parallel_process()`** & `process_segment()`：把长文本按行切片并发执行。

### 5.2 `esp_replacement_json_make_module.py`

- 与上面类似，但多了**构建 JSON** 时用到的辅助：  
  - `output_format()`：根据 “HTML格式_Ruby文字_大小调整” 等不同模式组合 `<ruby> <rt>` 或 `(...)` 等。
  - `remove_redundant_ruby_if_identical()`：如果 `<ruby>xxx<rt class="XXL_L">xxx</rt></ruby>` 一模一样就简化。
  - `process_chunk_for_pre_replacements()`/`parallel_build_pre_replacements_dict()`：将词表（含词性）并行处理成字典。

---

## 6. 常见问题 FAQ

1. **如何避免部分文本被错误替换？**  
   - 用 `%...%` 包裹，那些文本会跳过一切替换。
2. **如果文本体积非常大（几十万字母），是否会超时？**  
   - 可以尝试并行处理 (num_processes=4)。也可考虑在本地部署，不要在太慢的网络环境下远程运行。
3. **为什么生成 JSON 文件特别大 (50MB~)？**  
   - 因为同时包含了所有世界语词根及其活用派生形。您可以自行裁剪 CSV 或精简词根分解设置，以减少规模。
4. **JSON 文件导入 main.py 时速度会慢吗？**  
   - 一次性加载 50MB 需要几秒钟，不过 `@st.cache_data` 能缓存这个过程，下次使用会更快。
5. **想自定义大小写处理（如开头大写）**？  
   - 代码中实现了“上文大写、全大写、首字母大写”三套机制，会自动为每个词条多生成 2 条替换规则。可按需在 `output_format()` 里再改。

---

## 7. 注意事项

1. **代码中大部分变量名、函数名均保留英文**，以免出现功能失效或难以维护情况。  
2. **小心编辑 `JSON` 文件**：文件中的数组格式要保持一致，可参考示例 JSON 里的注释。
3. 如果**生成 JSON 的 CSV 或自定义 JSON 太大**，浏览器可能等待较久。耐心即可，或开启并行处理。

---

## 8. 总结

- **main.py**：主界面，用 JSON 文件替换世界语文本。
- **用于生成世界语文本(含汉字)替换的 JSON 文件工具.py**：生成那份 JSON 文件的辅助页。
- **esp_text_replacement_module.py / esp_replacement_json_make_module.py**：底层支撑逻辑。

通过以上功能，您可以方便地：  
**(1)** 准备 CSV/自定义 JSON；  
**(2)** 在“生成工具”页合并为一个大 JSON；  
**(3)** 在“主页面”把大 JSON 导入，输入世界语文本，一键得到汉字/中文注释的转换结果！  

祝您使用愉快！如有任何问题，欢迎查看代码注释或在 GitHub 上提交 Issue。
