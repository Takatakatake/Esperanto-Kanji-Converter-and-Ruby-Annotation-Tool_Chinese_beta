以下是两份中文版本的 Markdown 说明文档，分别对应您提供的两份日文版 README（即「README_使用方法.md」和「README_内部实现原理.md」）。为了确保内容结构及层次与日文版相同，以下翻译在保持原本文档段落顺序、标题层级的同时，以尽量准确且详实的中文进行阐述。**如有任何疏漏或您希望的调整之处，可再行指示，本文将竭力做到无任何错误或遗漏。**

---

# README_使用方法.md （中文翻译版）

## Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Beta

---

## 目录
1. **本应用简介**
2. **应用包含的页面（界面）说明**
   - 2.1. 主页面：世界语文本的替换与注音（`main.py`）
   - 2.2. 辅助页面：生成替换用 JSON 文件的工具（`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`）
   - 2.3. 辅助模块代码（`esp_text_replacement_module.py` 和 `esp_replacement_json_make_module.py`）
3. **主页面的用法（世界语文本的替换与注音）**
   1. 选择读取 JSON 文件的方式
   2. 关于占位符 (placeholders) 的读取
   3. 高级设置（并行处理）
   4. 选择输出形式
   5. 准备输入文本
   6. 执行转换
   7. 结果预览与下载
   8. 链接到 GitHub 仓库
4. **辅助页面的用法（生成替换用 JSON 文件）**
   1. 页面开头的概要说明
   2. 下载示例文件（CSV、JSON、Excel 等）
   3. 指定输出形式（“HTML 形式”“括号形式”等）
   4. 上传或使用默认 CSV 文件
   5. 上传或使用默认 JSON 文件（词根分解规则与替换后文字设置）
   6. 高级设置（并行处理）
   7. 生成 → 下载替换用 JSON 文件
5. **常见疑问（Q&A）**
   - A. 用 `%...%` 和 `@...@` 括起来的作用
   - B. 是否应当勾选“使用并行处理”
   - C. 下载文件（.json / .csv / .html等）之后的用途
6. **注意事项与故障排查**

---

## 1. 本应用简介

本应用主要提供以下两项核心功能：

1. **「根据指定规则，将世界语文本替换为（汉字）或生成附带翻译 Ruby（注音）的 HTML 格式」**  
   - 通过主页面（`main.py`）提供的功能实现：用户可手动输入或上传文本文件，并指定一份“替换规则 JSON 文件”，即可将世界语文本批量替换为对应汉字并为其加上注音。处理结束后，用户可在页面上直接查看或以 HTML 等格式下载结果。

2. **「生成替换用 JSON 文件（包含大量替换规则）」**  
   - 通过辅助页面（`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`）提供的功能实现：它会基于世界语词根与翻译/汉字等的对应 CSV 文件等多种输入，合并生成一个最终的大型 JSON 文件，其中包含各种替换规则。此文件可在主页面中上传并使用，从而在世界语文本替换过程中发挥作用。

此外，应用内部还包含**`esp_text_replacement_module.py`** 与 **`esp_replacement_json_make_module.py`** 两个模块。它们实现了正则化文本、加注 Ruby 的逻辑，以及对世界语词根进行汉字替换的通用函数与并行处理等功能，供主页面与辅助页面调用。若你只是在界面（GUI）上使用本应用，无需直接操作这些模块；但若你想深入了解其内部替换机理或进行自定义开发，则可查看这些模块的源代码。

---

## 2. 应用包含的页面（界面）说明

### 2.1. 主页面：世界语文本的替换与注音（`main.py`）

- 页面标题：**「将世界语文本替换为汉字、或在 HTML 形式中附加译注（扩展版）」**  
- 主要功能：
  1. 读取替换规则 JSON 文件（可使用默认或上传自定义文件）
  2. 选择如何提供世界语文本（手动输入或文件上传）
  3. 指定文本替换的输出形式（HTML 注音、括号形式等）
  4. `%...%` 形式的“跳过替换”、`@...@` 形式的“局部替换”功能
  5. 勾选是否启用并行处理，以及设置并行进程数
  6. 在屏幕上预览处理结果，或以各种格式（HTML 等）下载

### 2.2. 辅助页面：生成替换用 JSON 文件的工具（`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`）

- 页面标题：**「生成用于世界语文本（汉字）替换的 JSON 文件」**  
- 主要功能：
  1. 上传（或使用默认）CSV 文件与自定义 JSON 设置文件
  2. 在大规模 CSV 词根表的基础上，合并生成最终可用于替换的 JSON 规则文件
  3. 提供多个示例文件（CSV、JSON、Excel 等）供用户下载参考
  4. 最终可下载生成的 JSON 文件，供主页面中使用

### 2.3. 辅助模块（`esp_text_replacement_module.py` 与 `esp_replacement_json_make_module.py`）

- **`esp_text_replacement_module.py`**  
  - 用于在主页面执行文本替换的函数库，例如：
    - `orchestrate_comprehensive_esperanto_text_replacement`: 从空白字符正则化、字母形式转换，到跳过/局部/大域替换等流程的核心
    - `%...%` 与 `@...@` 的跳过或局部替换逻辑
    - 并行处理函数 `parallel_process` 等

- **`esp_replacement_json_make_module.py`**  
  - 用于在辅助页面生成替换用 JSON 文件时所需的函数库，例如：
    - `parallel_build_pre_replacements_dict`: 批量并行处理大规模词根数据
    - `output_format`: 根据用户的选择（HTML 注音、括号等）对输出字符串进行格式化
    - 将 CSV 与 JSON 数据合并到最终替换 JSON 的关键逻辑等

---

## 3. 主页面的用法（世界语文本的替换与注音）

下文将根据**主页面**（`main.py`）的界面流程，依次介绍具体操作步骤。

### 3.1. 选择读取 JSON 文件的方式

1. 在界面上方，会有一个单选框  
   **「JSON 文件怎么处理？（读取替换用 JSON 文件）」**  
   - 「使用默认 JSON」  
   - 「上传 JSON 文件」  

2. 若仅想简单试用，可选“使用默认 JSON”即可。  
   若你已有自己编制的 JSON 文件（含大量自定义替换规则），可选“上传 JSON 文件”并指定文件。

3. 一旦 JSON 成功读取，将显示“成功读取默认/上传的 JSON 文件”消息。

4. **参考**：若想获取示例 JSON 文件，也可在页面上找到“下载示例 JSON（替换用）”按钮，用以下载示例 JSON 并自行修改后再上传使用。

---

### 3.2. 关于占位符 (placeholders) 的读取

- 页面中会自动调用 `import_placeholders(...)` 去读取：
  - 用于跳过替换的 `%...%` 占位符列表
  - 用于局部替换的 `@...@` 占位符列表
- 对用户而言无需手动操作：只要知道**“% 括起来的内容会完全跳过替换”，“@ 括起来的内容会另用专门的替换列表”**即可。详细用法见后续 Q&A。

---

### 3.3. 高级设置（并行处理）

- 页面下方有 **“并行处理的高级设置”**:
- 如果勾选「使用并行处理」，则在替换文本时可利用多核 CPU，并行处理能加速对大文本的替换。不过在某些环境（如云端或受限 CPU）下可能会遇到限制。
- 「并行进程数」通常推荐在 2～4 间。如果设置过大，管理进程的额外成本可能会导致性能下降。

---

### 3.4. 选择输出形式

- **「选择输出格式（与生成替换用 JSON 时相同的格式）」**  
  可选项包括：
  1. HTML格式_Ruby文字_大小调整
  2. HTML格式_Ruby文字_大小调整_汉字替换
  3. HTML格式
  4. HTML格式_汉字替换
  5. 括弧(号)格式
  6. 括弧(号)格式_汉字替换
  7. 替换后文字列のみ(仅)保留(简单替换)

- **示例**：  
  - 若选 **“HTML格式_Ruby文字_大小调整”**，最终会以 `<ruby>...</ruby>` 将世界语文本与注音（译文）包裹，并附带调整 Ruby 字体大小的 CSS，使浏览器能直观显示带 Ruby 的文本。  
  - 若选 **“括弧(号)格式”**，则结果会以 `(注音)` 的括号形式直接插入到文本中。

---

### 3.5. 准备输入文本

- **「输入文本的来源」**  
  - 单选框：  
    1. 「手动输入」  
    2. 「文件上传」  

- **文件上传**场景：  
  - 上传 `.txt`、`.md`、`.csv` 等 UTF-8 编码的文本文件  
  - 上传成功后，界面会提示「文件已读取」。

- **手动输入**场景：  
  - 屏幕上会有一个多行文本输入框，用户可直接粘贴世界语文章或键入内容。

---

### 3.6. 执行转换

1. 在输入框输入世界语文本后，需在页面表单中指定：
   - **“输出字符形式”**（上标形式、x 形式或 ^ 形式）
     - 例如选“上标形式”，则最终生成的世界语字符会呈现上标形（字上符）的格式；若选“x 形式”，则生成如 `cx` 而非 `ĉ`。此处仅做文本层面的再次转换。
   - 点击 **“发送”** 按钮即可。

2. 点击后，应用内部会依序进行：
   - （%...% 跳过、@...@ 局部替换）
   - （大域替换、2 字母词根替换）
   - （生成所选输出形式）
   - …直到完成。

---

### 3.7. 结果预览与下载

- 处理结束后，页面下方会显示**「替换结果」**：
  - 若文本过多，只显示前若干行与末 3 行，中间用 `...` 省略。
- 若输出选了 **HTML** 格式，会出现两个 Tab：
  - Tab1: 显示内嵌的 HTML 预览（通过 `components.html()`）
  - Tab2: 显示 HTML 源码（`<ruby>...</ruby>`等标签）
- 在下方可点击 **「下载转换结果」** 按钮，将生成的内容保存为 `.html` 等文件。

---

### 3.8. 链接到 GitHub 仓库

- 页面末尾有 **“本应用的 GitHub 仓库”** 链接，点击可跳转到 GitHub 查看此应用的源代码。如需查看实现细节或提交问题，可以在该仓库中进行。

---

## 4. 辅助页面的用法（生成替换用 JSON 文件）

该页面位于 `pages` 文件夹下，文件名为 **`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`**，标题是「生成用于世界语文本（汉字）替换的 JSON 文件」。它适合想要自行编写 CSV / JSON 文件来定制大量世界语词根—汉字映射规则的用户。

### 4.1. 页面开头的概要说明

- 打开该页面，会先看到一个折叠区 **「使用说明」**，示例流程如下：
  1. 上传或使用默认的 **CSV** 文件（世界语词根到中文/汉字的对应表）
  2. （可选）上传或使用默认的 **JSON** 文件（自定义词根分解、替换后文字等细节）
  3. 选择输出形式（HTML 格式、括号形式、或仅替换等）
  4. 点击生成并下载 **替换用 JSON 文件**，然后在主页面中上传使用

---

### 4.2. 下载示例文件（CSV、JSON、Excel 等）

- 在 **「示例文件列表（点击下载）」** 折叠区，可下载多种样例，如：
  - **示例 CSV 1：世界语词根-中文注释对照表**
  - **示例 CSV 2：世界语词根-汉字对照表（Mingeo 方案）**
  - **示例 JSON 1：世界语单词词根分解法的用户自定义设置**
  - **示例 JSON 2：替换后文字列的用户自定义设置**（通常不太推荐的配置也会出现）
  - **示例 Excel：世界语词根-日语注释的对照表（带掌握等级）**  
- 只需点击对应按钮即可直接下载文件。你可用它们做参考或在编辑后再次上传。

---

### 4.3. 指定输出形式（“HTML 形式”“括号形式”等）

- 在页面中部有一个下拉菜单 **「请选择输出格式」**：
  - 例如选 **「HTML格式_Ruby文字_大小调整」**，系统会在生成 JSON 时，就把“世界语词根 → （HTML）带 Ruby 注音”当作最终的替换文本。  
  - 或者选 **「括弧(号)格式_汉字替换」**，则会生成如 `汉字(世界语词根)` 的形式。

---

### 4.4. 上传或使用默认 CSV 文件

- **「第一步：准备 CSV 文件」**  
  - 你可选择“上传 CSV”或“使用默认 CSV”  
  - CSV 需包含两列：第一列是世界语词根，第二列是对应翻译（汉字/中文/注音等）
- 如果上传 CSV，会内部用 `convert_to_circumflex(...)` 将其中的 `cx`、`c^` 等转成 `ĉ`。  
- 如果使用默认 CSV，则系统会自动加载示例文件。

---

### 4.5. 上传或使用默认 JSON 文件（词根分解规则与替换后文字设置）

- **「第二步：准备 JSON 文件（词根分解法等）」**  
  - 可上传或使用默认的 JSON：  
    1. “词根分解法 JSON”  
    2. “替换后文字自定义 JSON”  
  - 若不做特殊定制，默认 JSON 里已经包含许多基础逻辑，可满足常见需求。

---

### 4.6. 高级设置（并行处理）

- **「第三步：并行处理（高级设置）」**  
  - 与主页面类似，可通过勾选启用多进程，以加快对大规模数据的处理。  
  - 在生成数万行的替换规则时，能明显减少等待时间，但需注意 CPU 资源是否足够。

---

### 4.7. 生成 → 下载替换用 JSON 文件

1. 点击 **“生成并下载替换用 JSON 文件”** 按钮，系统会：
   - 读取内部大词库（含几万条世界语单词 + 品词信息）
   - 将 CSV、用户自定义 JSON 中的规则整合
   - 根据各种规则自动附加动词后缀、名词结尾等
   - 最后得到**三大列表**（全域替换 / 二字词根 / 局部替换）
   - 将其打包为 `.json`
2. 出现下载按钮后，点击即可保存到本地
3. 日后在主页面用“上传 JSON 文件”方式读取，就可使用这些自定义规则来替换世界语文本。

---

## 5. 常见疑问（Q&A）

### A. 用 `%...%` 和 `@...@` 括起来的作用

- **`%...%`**：**跳过替换**  
  - 被 `%` 括起来的段落将不会被任何替换规则所改动。  
  - 例如：`Mi havas %nombro% da libroj.` 其中 `%nombro%` 不会被翻译或替换。
- **`@...@`**：**局部替换**  
  - 被 `@` 括起来的段落不会执行全局替换，而是由专门的“局部替换列表（replacements_list_for_localized_string）”进行处理。  
  - 例如：`Mi @amas@ vin.` 若你对 `amas` 有特别设置，就只会在这里执行，不影响他处相同词。
- 通过这两种标记，能灵活指定“完全不替换的区域”或“只做特殊替换的区域”。

### B. 是否应当勾选“使用并行处理”

- 一般来说，如果文本行数很多，勾选并行处理能充分利用多核 CPU，加速整体替换过程。  
- 但在云端或 CPU 核心不多的环境下，也可能出现速度并无显著提升，甚至因管理进程而变慢。所以可先在默认（不并行）下试用，再视需求决定是否开启。

### C. 下载文件（.json / .csv / .html等）之后的用途

- **`.json`**（替换用 JSON 文件）：在主页面可以“上传 JSON”以使用该规则；  
- **`.csv`**：可在生成或编辑新的词根表时再次使用，或在 Excel 中修改后重新上传生成 JSON；  
- **`.html`**：当你在主页面下载了替换结果（HTML）时，直接打开即可看到带注音/汉字替换的完整文本，也可在任意文本编辑器中查看/改动源代码。

---

## 6. 注意事项与故障排查

1. **文本编码：请使用 UTF-8**  
   - 若上传的文件非 UTF-8 编码，可能会出现乱码。
2. **大文本时的预览省略**  
   - 若输出文本太长，页面仅显示部分内容。若需查看全部，请下载后用本地编辑器打开。
3. **并行处理的兼容性**  
   - 在部分受限云环境中，并行处理可能会报错或被阻止。若无法正常执行，请尝试关闭并行处理。
4. **Ruby 在部分浏览器中对齐可能存在偏差**  
   - 若选择 “HTML格式_Ruby文字_大小调整”，有些旧版浏览器的渲染或 CSS 支持可能不完善，可考虑改用括号形式或自行调整 CSS。
5. **JSON 文件格式错误**  
   - 如果上传 JSON 时报错，请确认 JSON 文件语法正确（花括号、逗号、引号等成对匹配）。

---

# 结语

以上即本应用（主页面与辅助页面）的详细操作指南：

- **主页面**：直接“世界语 → (汉字/注音)”批量转换并下载结果  
- **辅助页面**：基于自定义 CSV/JSON 生成可选的替换用 JSON 文件，以满足更丰富的规则需求  

若要进一步了解内部逻辑，可参考同目录下的两个模块（`esp_text_replacement_module.py`、`esp_replacement_json_make_module.py`）以及 GitHub 仓库。在那里可看到如何实现 Ruby 尺寸调节、并行处理等细节。

如果在使用中遇到任何问题或发现 Bug，欢迎在**GitHub 仓库的 Issue** 区进行反馈。希望本说明文档能帮助你顺利使用本应用的 GUI 功能！  

---

<br><br>

# README_内部实现原理.md （中文翻译版）

## Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Beta

下文是关于本应用（`main.py`、`用于生成世界语文本(含汉字)替换的 JSON 文件工具.py`、`esp_text_replacement_module.py`、`esp_replacement_json_make_module.py`）内部工作机制的说明，重点介绍**各部分是如何协同工作、数据流如何运转**，适合已经熟悉基本 GUI 操作，但想深入了解替换流程、JSON 生成逻辑、模块之间调用顺序的读者。

---

## 目录

1. **整体架构概述**  
   1.1 主页面 (main.py) 与辅助页面 (用于生成世界语文本(含汉字)替换的 JSON 文件工具.py)  
   1.2 字符串（汉字）替换模块 (esp_text_replacement_module.py)  
   1.3 生成 JSON 文件的模块 (esp_replacement_json_make_module.py)  

2. **主页面 main.py 的运行机制**  
   2.1 读取 JSON 文件的逻辑  
   2.2 读取 placeholders（占位符）  
   2.3 并行处理的设置与注意事项（multiprocessing / spawn start method）  
   2.4 获取输入文本（手动或文件）  
   2.5 执行替换的流程  
   2.6 应用输出格式（HTML/括号/仅替换等）  
   2.7 下载与最终显示  

3. **辅助页面 用于生成世界语文本(含汉字)替换的 JSON 文件工具.py 的运行机制（当想自行生成 JSON 时）**  
   3.1 如何处理 CSV 文件与用户自定义 JSON 文件  
   3.2 如何将它们合并为最终三类列表（全域 / 局部 / 二字词根）  
   3.3 关于动词、名词等尾缀扩展的细节  
   3.4 如何给海量数据分配优先级（基于字数 × 10000）  

4. **esp_text_replacement_module.py（文本替换模块）的细节**  
   4.1 世界语字符转换（ĉ 等）相关函数  
   4.2 大域替换 / 局部替换 / `%...%` 跳过替换 / placeholders 机制  
   4.3 orchestrate_comprehensive_esperanto_text_replacement() 的具体流程  
   4.4 parallel_process() 并行处理  

5. **esp_replacement_json_make_module.py（生成 JSON 模块）的细节**  
   5.1 结合 CSV 数据与 safe_replace()  
   5.2 output_format()：多种形式（HTML、括号等）的注音或汉字替换  
   5.3 parallel_build_pre_replacements_dict() 并行化处理  
   5.4 remove_redundant_ruby_if_identical()（去重 Ruby 技巧）  

6. **补充说明**  
   6.1 基于字数进行“替换优先级”设计的原因  
   6.2 与 Streamlit 相关的注意点（会话状态、页面布局、@st.cache_data 等）  
   6.3 处理 50MB 级别 JSON 时的性能策略  

---

## 1. 整体架构概述

### 1.1 主页面 (main.py) 与辅助页面 (用于生成世界语文本(含汉字)替换的 JSON 文件工具.py)

- **主页面 (main.py)**  
  这是应用启动后默认打开的页面，用于**读取“替换用 JSON 文件”**并对世界语文本进行“批量替换 → 下载结果”。
- **辅助页面 (用于生成世界语文本(含汉字)替换的 JSON 文件工具.py)**  
  这是个 Streamlit 的次级页面，专门用于**生成用于替换的 JSON 文件**。它将 CSV / 用户自定义 JSON 合并成最终的“大型替换规则 JSON”。主页面可以读取这个 JSON 来执行文字替换。

### 1.2 字符串（汉字）替换模块 (esp_text_replacement_module.py)

- 其中包含：
  - 世界语特殊字符转换（把 `cx`或`c^` 等转为 `ĉ`），
  - `%...%` 与 `@...@` 的跳过/局部替换机制，
  - 并行处理方法（按行分割）等  
  - 核心函数 `orchestrate_comprehensive_esperanto_text_replacement()` 实现**一体化**替换流程。

### 1.3 生成 JSON 文件的模块 (esp_replacement_json_make_module.py)

- 在辅助页面中用来**整合 CSV、用户自定义配置**并输出三大替换列表（全域/二字词根/局部）作为 JSON。  
- 内部采用多进程并行以加快大规模数据处理，如 `parallel_build_pre_replacements_dict()`。

---

## 2. 主页面 main.py 的运行机制

### 2.1 读取 JSON 文件的逻辑

```python
selected_option = st.radio("...", ("使用默认 JSON", "上传 JSON 文件"))
...
if selected_option == "使用默认 JSON":
    # 调用 load_replacements_lists(默认路径)
else:
    # file_uploader -> json.load(...)
```
- 读取后，存入 `replacements_final_list`, `replacements_list_for_localized_string`, `replacements_list_for_2char` 三个列表。  
- 通过 `@st.cache_data` 加快加载。

### 2.2 读取 placeholders（占位符）

```python
placeholders_for_skipping_replacements = import_placeholders(...)
placeholders_for_localized_replacement = import_placeholders(...)
```
- `%...%`（跳过替换）与 `@...@`（局部替换）的内部占位符分别存放于两个文件，自动读取并在替换时使用。

### 2.3 并行处理的设置与注意事项（multiprocessing / spawn start method）

```python
try:
    multiprocessing.set_start_method("spawn")
except RuntimeError:
    pass
```
- 必须使用 `spawn` 方式，以避免在 Streamlit 环境出现 PicklingError。

```python
use_parallel = st.checkbox("并行处理", value=False)
num_processes = st.number_input(...)
```
- 用户可自定义是否启用多进程，以及进程数量。

### 2.4 获取输入文本（手动或文件）

- `source_option = st.radio("手动输入" / "文件上传")`
- 若上传文件，则 `st.file_uploader` 并 `decode("utf-8")`；若手动输入，则通过文本框 `st.text_area` 获取。

### 2.5 执行替换的流程

1. 点击“提交”按钮后，根据是否启用并行调用：
   - `parallel_process(text, num_processes, ...)`
   - 或 `orchestrate_comprehensive_esperanto_text_replacement(text, ...)`
2. `orchestrate_...` 函数内则依次执行：
   - 空白字符正则化
   - 转换 `cx` 等为 `ĉ`
   - `%...%` 跳过、`@...@` 局部替换
   - 大域替换
   - 2 字母词根二次替换
   - 还原 placeholder
   - 若是 HTML，则插入 `<br>`、`&nbsp;`。

### 2.6 应用输出格式（HTML/括号/仅替换等）

- 由 `format_type`（下拉列表）决定。可能包括 “HTML格式_Ruby文字_大小调整”、“括弧(号)格式” 等。  
- 若选 HTML，则会在结果中插入 `<ruby>...</ruby>` 并可能带 CSS 样式。

### 2.7 下载与最终显示

- 生成 `processed_text` 后，通过：
  - 若是 HTML，则在页面中以 `components.html(...)` 预览
  - “下载转换结果 (HTML)” 按钮让用户保存 `.html`
- 同时为大文本做截断显示，以免页面卡顿。

---

## 3. 辅助页面 用于生成世界语文本(含汉字)替换的 JSON 文件工具.py 的运行机制（当想自行生成 JSON 时）

### 3.1 如何处理 CSV 文件与用户自定义 JSON 文件

- 首先用户选择上传或使用默认 CSV。  
- 然后再上传或使用默认 JSON（可能包含“词根分解法”、“替换后文字”两个部分）。  
- 这些文件会在脚本内统合成一个大规模字典或列表，为后续“生成替换用 JSON”做准备。

### 3.2 如何将它们合并为最终三类列表（全域 / 局部 / 二字词根）

- 脚本中的核心逻辑：
  1. 从内部“世界语词根”与“品词”庞大数据中，加上 CSV 覆盖的“译文/汉字”；
  2. 对动词、名词等自动添加后缀和词尾；  
  3. 对 user_replacement_item_setting_list（用户自定义替换）进行额外修正或排除；  
  4. 将结果分别存入：
     - `replacements_final_list`（全域替换）
     - `replacements_list_for_2char`（二字词根的特殊处理）
     - `replacements_list_for_localized_string`（局部替换用）
  5. 最终写入 JSON 文件供下载。

### 3.3 关于动词、名词等尾缀扩展的细节

- 源码中大量 if/else 判断，如：“若 `i` 以 `an` 结尾且是名词，则可能还要添加 `i + "o"`、`i + "a"` 等”等逻辑。这使得一个基础词根能自动衍生出若干形态（例如动词时态、名词复数等）。  
- 这些衍生词往往以 `(长度 × 10000)` 形式赋予优先级，确保复杂词先被替换。

### 3.4 如何给海量数据分配优先级（基于字数 × 10000）

- 应用通过“长单词”优先替换，避免“短单词”先替换导致冲突。例如 `transliterator` 不应被 “trans + liter + ...”提前抢占。  
- 所以，生成 JSON 时，会给每个单词 `old` 赋予 `len(old)*10000` 的优先值并进行降序处理，以保证越长的 `old` 越早替换。

---

## 4. esp_text_replacement_module.py（文本替换模块）的细节

这里集中了主页面实际调用的大部分替换逻辑。

### 4.1 世界语字符转换（ĉ 等）相关函数

- `x_to_circumflex`、`hat_to_circumflex` 等字典可完成：
  - `cx -> ĉ`, `c^ -> ĉ` 等多种形式间的转换
- `convert_to_circumflex(text)`：先后应用 `hat_to_circumflex`、`x_to_circumflex`，使文本统一为带字上符的形式。

### 4.2 大域替换 / 局部替换 / `%...%` 跳过替换 / placeholders 机制

- `%...%`：跳过替换  
  - 先把 `%...%` 内容替换成独特 placeholder，后续就不会做任何替换
- `@...@`：局部替换  
  - 只使用 `replacements_list_for_localized_string`，而不走全域替换
- placeholders 主要用于避免替换冲突：  
  - 例如 `(old -> placeholder -> new)` 比单纯 `old -> new` 更安全，不会发生替换后的字符串再次匹配到 `old` 的情况。

### 4.3 orchestrate_comprehensive_esperanto_text_replacement() 的具体流程

- 核心流程可概括为：
  1. 标准化空白与世界语字符
  2. `%...%` 跳过
  3. `@...@` 局部处理
  4. 全域替换列表
  5. 二字词根替换两轮
  6. 还原 placeholders
  7. 若是 HTML，插入 `<br>` 与 `&nbsp;`

### 4.4 parallel_process() 并行处理

- 对长文本按行拆分，通过 `multiprocessing.Pool` 并行调用 `process_segment()`；后者再调用 `orchestrate_...`。  
- 行数越多，分割越细，并行优势越明显。

---

## 5. esp_replacement_json_make_module.py（生成 JSON 模块）的细节

这是辅助页面生成大型 JSON 时最关键的模块。

### 5.1 结合 CSV 数据与 safe_replace()

- 先读 CSV （词根 -> 注释/汉字）。  
- 用 `safe_replace()` 等机制，把重复或冲突替换处理得更稳妥。

### 5.2 output_format()：多种形式（HTML、括号等）的注音或汉字替换

```python
def output_format(main_text, ruby_content, format_type, char_widths_dict):
    # 根据 format_type 决定是 <ruby>...<rt>...</rt></ruby> 还是 (注音) 等
```
- 对“HTML格式_Ruby文字_大小调整”这类，会测量字符串宽度（Arial16）并在过长时自动插入 `<br>` 以换行。
- 对“括弧(号)格式”则直接 `main_text(ruby_content)`

### 5.3 parallel_build_pre_replacements_dict() 并行化处理

- 类似 main.py 并行处理，但面向“词根与品词信息”大列表做预处理，合并 partial 字典。

### 5.4 remove_redundant_ruby_if_identical()（去重 Ruby 技巧）

- 用正则 `IDENTICAL_RUBY_PATTERN` 匹配 `<ruby>xxx<rt>xxx</rt></ruby>` 并改回 `xxx`，防止出现“同一字符串 = 主体 + ruby 文本”的冗余情况。

---

## 6. 补充说明

### 6.1 基于字数进行“替换优先级”设计的原因

- 为避免“较短词根”优先替换，破坏“较长词根”匹配的需求。  
- 所以让 (长度更长) 的单词优先被替换，以提升正确率。

### 6.2 与 Streamlit 相关的注意点（会话状态、页面布局、@st.cache_data 等）

- **@st.cache_data**：缓存读取 JSON 结果，减少重复加载。
- **会话状态 (st.session_state)**：用于在提交表单后保留文本。
- **layout="wide"** 和 `components.html()` 用于在页面嵌入更大宽度的 HTML 预览区域。

### 6.3 处理 50MB 级别 JSON 时的性能策略

- 使用并行处理加速；  
- 在 main.py 加上 `@st.cache_data` 缓存；  
- 根据行数选择是否并行，以免因为进程开销适得其反。

---

# 总结

本应用围绕**“将世界语文本替换为汉字并可附加注音”**这一核心需求，做了多方面的扩展：

- **主页面**(main.py)：供最终用户操作，实现文本 → (汉字/注音) 的自动转换  
- **辅助页面**：合并 CSV/JSON 生成替换规则 JSON，便于自定义大规模规则  
- **两个模块**：
  - `esp_text_replacement_module.py`：具体执行跳过/局部/大域替换，支持并行处理  
  - `esp_replacement_json_make_module.py`：负责根据 CSV / 自定义词根分解规则构建庞大 JSON

在云端或本地使用时，若文本量较大，可酌情使用多进程提高速度；若要调整替换细节，可参考 user_replacement_item_setting_list 或自定义 JSON 进行深度修改。通过了解其内部原理，你可以更好地在此框架上进行二次开发或个性化扩展。祝使用顺利！  

（完）
